# 算法题

## 青蛙跳台阶

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

示例如下:

```js
// 输入：n = 2
// 输出：2
// 示例 2：

// 输入：n = 7
// 输出：21
// 示例 3：

// 输入：n = 0
// 输出：1
```

思路:

动态规划解析：

* 状态定义： 设arr为一维数组，其中 arr[i] 的值代表斐波那契数列第i个数字 。
* 转移方程： arr[i + 1] = arr[i] + arr[i - 1] ，即对应数列定义 f(n + 1) = f(n) + f(n - 1)；
* 初始状态： arr[0] = 0, arr[1] = 1 ，即初始化前两个数字；
* 返回值： arr[n] ，即斐波那契数列的第 n 个数字。

空间复杂度优化：

若新建长度为n的arr列表，则空间复杂度为O(N)。

由于 arr 列表第 i 项只与第 i-1 和第 i-2 项有关，因此只需要初始化三个整形变量 sum, a, b ，利用辅助变量 sum 使 a, b两数字交替前进即可 （具体实现见代码） 。

节省了 arr 列表空间，因此空间复杂度降至 O(1) 。如下图所示:

<div class="image-container">
    <img src="https://eveningwater.github.io/to-offer/images/fib-1.png" alt="斐波那契数列" title="斐波那契数列" >
</div>

## 第n个丑数

再来看一道:我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数?

```js
// 输入: n = 10
// 输出: 12
// 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
```

说明:

* 1 是丑数。
* n 不超过1690。


思路:

状态定义： 设动态规划列表 dp ，dp[i] 代表第 i + 1 个丑数；

转移方程：

当索引 a, b, c满足以下条件时， dp[i]为三种情况的最小值；

每轮计算 dp[i] 后，需要更新索引 a, b, c的值，使其始终满足方程条件。

实现方法：分别独立判断 dp[i] 和 dp[a] = dp[a] × 2 , dp[b] = dp[b]×3 , dp[c] = dp[c]×5 的大小关系，若相等则将对应索引 a , b , c 加 1；

```js
// dp[a]×2 > dp[i−1] ≥ dp[a−1]×2
// dp[b]×3 > dp[i−1] ≥ dp[b−1]×3
// dp[c]×5 > dp[i−1] ≥ dp[c−1]×5
```

则有:

```js
// dp[i] = min(dp[a] × 2,dp[b] × 3,dp[c] × 5)
```

初始状态： dp[0] = 1，即第一个丑数为1；

返回值： dp[n-1]，即返回第 n 个丑数；

## 总结

动态规划核心思想:

1. 状态定义
2. 寻找状态更改规律->状态转移方程
3. 状态转移方程的优化(时间复杂度与空间复杂度之间寻找平衡)

动态规划适用于什么场景?

根据以上两题，我们可以得到，当我们可以将一个问题转化成多个子问题并且我们想要求出最优解的时候，我们就可以使用动态规划算法思想来解决问题。

[动态规划](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin)。
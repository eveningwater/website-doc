# 状态管理

在熟读本文档之前，你需要通读[vuex文档](https://vuex.vuejs.org/zh/)，必须要理解vuex的详细用法。

首先，在谈到状态管理之前，我们来思考一下如下三个问题:

1.什么是状态?

2.状态为什么要管理？

3.如何去管理?

## 理解状态

我来谈一下理解，前端发展到现在，我们已经不再去关注DOM操作了，正因为有Vue与react框架的出现，所以也诞生了一种新的开发模式结构。即:
`View UI = f(state)`。也就是说我们只关心状态，对状态进行一些增删改查的操作，而具体的状态的变更对应视图的更新则已经在框架内部为我们处理呢。

讲到这里，或许大家就明白了，其实vue和react的本质都是用状态来映射视图，它们之间的区别无非就是修改状态和更新视图的模式不同。比如vue是通过一个data，或者也可以理解为是定义一个data选项来约定你所定义的状态必须在data当中，然后通过一些方法来监听data的改变从而自动响应的更新视图。

而react则是通过约定一个state选项，然后通过调用setState方法来通知视图更新。更确切的说，就是vue是通过推(push)的方式，而react则是通过拉(pull)的方式来更新视图。

所谓推，就是说我们状态发生改变，会把这种改变推入一个队列中去，然后队列中存储的依赖只要绑定了这种改变就都会更新。而所谓拉的方式，也就是说我们状态发生改变，我们需要约定一个方式去拉动相关视图依赖的更新。（这里就讲远了）

我们回到状态这一点，我们都知道不管是react也好，还是vue也好，它们都是基于组件而开发。而要将这些组件关联起来，就需要数据通信，这种数据通信，我们就可以称之为状态。比如vue将状态定义在data中，react将状态定义在state中。

因此对前端开发工程师而言，挑战变成了如何更好的去定义、更新、存储、共享这些状态，因为状态在某一时刻的快照与视图一一对应，且非常具有函数式编程范儿的（同样的输入一定有相同的输出，同样的状态一定对应一样的视图展示）。

> 状态管理是当前前端最核心的部分，因为视图能用状态描述，所以前端的逻辑复杂度移到了如何让状态“不要出错”，前端与后端的一个区别在于，状态在前端是长生命周期的，又会在这个生命周期中有不可枚举地、未知地、难以追踪的多次修改，保证其按照既定轨迹不出错就很困难了

> 为什么说是某一时刻，状态不是一成不变的，实际业务场景中，状态是一直在被改变的，从而带来视图的随之更新。

最广义程度来看，状态本质是还是一种可以描述视图状态、行为的数据结构，状态的管理则是通过一定的算法将这些数据结构组织、管理起来，又回到了 `程序=算法+数据结构` 这一基本概念。

## 状态分类

状态大致可以分为两类，**本地状态**和**共享状态**

本地状态就是 `vue` 中的 `data`，`react`中的 `state`，这里我们一般会用来控制弹窗的现实隐藏、`loading`效果等

共享状态其实是最头疼的问题，但又是最常见的场景，业务中肯定会出现大量需要兄弟节点通信、祖孙节点通信等情况的场景，通信的目的是为了状态分享，虽然可以通过一些方式，比如回调函数等手段实现，但都不是最佳实践

> 一般情况下，你不需要什么状态管理工具，简单是避免麻烦的最佳实践，当你的应用膨胀到你已经无法理顺状态流的时候，才是你考虑使用状态管理工具的时机
>
> 项目的复杂度和组件层次结构的复杂性是衡量是否使用状态管理工具的标准，这多多少少取决于经验


## 状态管理的方式：中心化和去中心化两种模式

`Dan` 曾经说过 `SPA` 应用最佳实践是分为容器组件和展示组件，通过 `props` 向下传递状态，这样分层之后的好处显而易见，只需要维护好容器组件内的状态就行，展示组件和业务逻辑解耦，但是真的是这样吗？分析公司内的项目代码，大家可能会发现，经常出现层级嵌套个5-6层的页面，这么传下去谁也不敢保证中间环节不出什么问题，还是做不到单一，解耦。

我们以vue举例，试想一下:

假设vue组件中有a和b组件，两者都共用一个属性，如果我们都定义在data选项中，那么我们必须都在这两个组件中定义这个属性。

```js
// a.vue
<h1>{{ username }}</h1>

// b.vue
<h2>
  {{ username }}
</h2>
```

可能有人会想到将数据定义在它们的父组件由它们的父组件分发给它们，但是如果它们的层级嵌套比较深，我们还需要一层一层的向下传递？

所以 `Flux` 架构及其追随者 `Redux` `Vuex`被提出。

[flux](http://caibaojian.com/react/flux.html)。主要思想是**应用的状态被集中存放到一个仓库中，但是仓库中的状态不能被直接修改**，**必须通过特定的方式**才能更新状态，比如flux包含四个部分，约定如下：

1. the dispatcher
2. the stores
3. the views
4. the actions

很显然dispatch与actions在这里就是这个特定的方式，如此一来，当我们完全控制了状态的改变，我们可以很容易的追踪状态的变化也让应用开发更容易调试。使用开发者工具我们不仅可以检查状态的变化，甚至可以回到上个状态（类似时间旅行）

## 状态划分

状态划分的粒度可大可小，`react` 社区最新的状态管理工具[recoil](https://github.com/facebookexperimental/Recoil) 从原子粒度 `atom` 来划分。

对我们而言，什么方式才是最好的呢？

有团队区分业务型和视觉模型，直白的说就是如视图控制的状态归一，业务逻辑相关的归一，看似美好且清爽，在实际业务实践下仍然有很大的难度，区分好模型完全靠经验，状态分的太多了共享，复用也是问题

我目前比较倾向于领域模型的方式，可参考[DDD 美团实践](https://tech.meituan.com/2017/12/22/ddd-in-practice.html)

理想的状态管理工具需要解决的问题

1. 状态更新的设计，`API` 足够少，且简单
2. 如何共享状态
3. 状态提升
4. 状态下降
5. 同步、异步的处理
6.  持久状态和临时状态如何区分维护
7.  状态更新的事务如何管理
8. 去中心化
9. ...

> [若川的vuex源码分析文章](https://juejin.cn/post/6844904001192853511)。

状态管理工具应该是集中式存储数据结构的，也就是所谓的中心化。换句话说就是用一种通用的数据结构来将组件之间的通信存放在全局状态中，这种数据结构我们可以称之为tree。这样做的好处就是为了避免数据的重复问题，同时也更好的管理了视图与数据之间的解耦。

实际上，flux架构已经为我们解决了更改状态的问题，也就是通过一种可以预测的方式去修改状态。而我们现在只需要考虑状态是同步还是异步更改，为了解决这个问题，我们约定一个术语，也即action（尽管action内部也是通过mutation来实现的）来异步更改状态，然后用mutation来实现同步更改。这样，我们就完美实现了一个闭环结构，用数据结构来说明，就是一个头尾相连的双链表。整个过程如下:

[页面dispatch（分发状态变更）和commit(提交状态变更)] -> [action/mutation更改状态]->[状态变更]->[页面更新]->[页面dispatch（分发状态变更）和commit(提交状态变更)]....

整个过程就是如上所展示的。
# 框架设计的核心要素

框架设计要比想象得复杂，并不是说只把功能开发完成，能用就算大功告成了，这里面还有很多学问。比如，我们的框架应该给用户提供哪些构建产物?产物的模块格式如何?当用户没有以预期的方式使用框架时，是否应该打印合适的警告信息从而提供更好的开发体验，让用户快速定位问题?开发版本的构建和生产版本的构建有何区别?热更新(hotmodulereplacement,HMR 需要框架层面的支持，我们是否也应该考虑?另外，当你的框架提供了多个功能，而用户只需要其中几个功能时，用户能否选择关闭其他功能从而减少最终资源的打包体积?上述问题是我们在设计框架的过程中应该考虑的。

学习本章时，要求大家对常用的模块打包工具有一定的使用经验，尤其是 [rollup.js](https://rollupjs.org/guide/en) 和 [webpack](https://webpack.js.org/) 如果你只用过或了解过其中一个，也没关系，因为它们的很多概念其实是类似的。如果你没有使用过任何模块打包工具，那么需要自行了解一下，有了初步认识之后再来阅读本章会更好一些。

## 提升用户的开发体验

衡量一个框架是否足够优秀的指标之一就是看它的开发体验如何，这里我们拿 Vue.js3 举个例子:

```vue
createApp(App).mount('#not-exist');
```

当我们创建一个 Vue.js 应用并试图将其挂载到一个不存在的 DOM 节点时，就会收到一条警告信息，如图 2-1 所示。

这条信息告诉我们挂载失败了，并说明了失败的原因:Vue.js 根据我们提供的选择器无法找到相应的 DOM 元素(返回 null)。这条信息让我们能够清晰且快速地定位问题。试想一下，如果 Vue.js 内部不做任何处理,那么我们很可能得到的是 JavaScript 层面的错误信息，例如 `Uncaught TypeError: Cannot read property'xxx’of null`，而根据此信息我们很难知道问题出在哪里。

所以在框架设计和开发过程中，提供友好的警告信息至关重要。如果这一点做得不好，那么很可能会经常收到用户的抱怨。始终提供友好的警告信息不仅能够帮助用户快速定位问题，节省用户的时间，还能够让框架收获良好的口碑，让用户认可框架的专业性。

在 Vue.js 的源码中，我们经常能够看到 warn 函数的调用，例如图 2-1 中的信息就是由下面这个 warn 函数调用打印的:

```js
warn(`Failed to mount app: mount target selector "${container}" returned
null.`);
```

对于 warn 函数来说，由于它需要尽可能提供有用的信息，因此它需要收集当前发生错误的组件栈信息。如果你去看源码，就会发现有些复杂，但其实最终就是调用了 console.warn 函数。

除了提供必要的警告信息外，还有很多其他方面可以作为切入口，进一步提升用户的开发体验。例如，在 Vue.js3 中，当我们在控制台打印一个 ref 数据时:

```js
const count = ref(0);
console.log(count);
```

打开控制台查看输出，结果如图 2-2 所示：

可以发现，打印的数据非常不直观。当然，我们可以选择直接打印 count.value 的值，这样就只会输出 0，非常直观。那么有没有办法在打印 count 的时候让输出的信息更友好呢?当然可以浏览器允许我们编写自定义的 formatter，从而自定义输出形式。在 Vue.js 3 的源码中，你可以搜索到名为 initCustomFormatter 的函数，该函数就是用来在开发环境下初始化自定义 formatter 的以 Chrome 为例，我们可以打开 DevTools 的设置然后勾选“Console”一“Enable custom formatters 选项，如图 2-3 所示。

然后刷新浏览器并查看控制台，会发现输出内容变得非常直观，如图 2-4 所示。

## 控制框架代码的体积

框架的大小也是衡量框架的标准之一。在实现同样功能的情况下,当然是用的代码越少越好这样体积就会越小，最后浏览器加载资源的时间也就越少。这时我们不禁会想，提供越完善的警告信息就意味着我们要编写更多的代码，这不是与控制代码体积相悖吗? 没错，所以我们要想办法解决这个问题。

如果我们去看 Vue.js3 的源码，就会发现每一个 warn 函数的调用都会配合`__DEV__`常量的检查，例如:

```js
if (__DEV__ && !res) {
  warn(`Failed to mount app: mount target selector
"${container}" returned null.`);
}
```

可以看到，打印警告信息的前提是:`__DEV__`这个常量一定要为 true，这里的`__DEV__`常量就是达到目的的关键。

Vue.js 使用 rollup.js 对项目进行构建，这里的`__DEV__`常量实际上是通过 rollup.js 的插件配置来预定义的，其功能类似于 webpack 中的 DefinePlugin 插件。

Vue.js 在输出资源的时候，会输出两个版本，其中一个用于开发环境，如 vue.global.js，另一个用于生产环境，如 vue.global.prod.js，通过文件名我们也能够区分。

当 Vue.js 构建用于开发环境的资源时，会把`__DEV__`常量设置为 true，这时上面那段输出警告信息的代码就等价于:

```js
if (true && !res) {
  warn(`Failed to mount app: mount target selector
"${container}" returned null.`);
}
```

可以看到，这里我们把`__DEV__`常量替换成字面量 true，所以这段代码在开发环境中是肯定存在的。

当 Vue.js 用于构建生产环境的资源时，会把`__DEV__`常量设置为 false，这时上面那段输出警告信息的代码就等价于:

```js
if (false && !res) {
  warn(`Failed to mount app: mount target selector
"${container}" returned null.`);
}
```

可以看到，`__DEV__`常量替换为字面量 false，这时我们发现这段分支代码永远都不会执行因为判断条件始终为假，这段永远不会执行的代码称为 dead code，它不会出现在最终产物中，在构建资源的时候就会被移除，因此在 vue.global.prod.js 中是不会存在这段代码的。

这样我们就做到了在开发环境中为用户提供友好的警告信息的同时，不会增加生产环境代码的体积。

## 框架要做到良好的 Tree-Shaking

上文提到通过构建工具设置预定义的常量`__DEV__`，就能够在生产环境中使得框架不包含用于打印警告信息的代码，从而使得框架自身的代码量不随警告信息的增加而增加。但是从用户的角度来看，这么做仍然不够，还是拿 Vue.js 来举个例子。我们知道 Vue.js 内建了很多组件，例如`<Transition />`组件，如果我们的项目中根本就没有用到该组件，那么它的代码需要包含在项目最终的构建资源中吗?答案是“当然不需要”，那么如何做到这一点呢?这就不得不提到本节的主角 Tree-Shaking。
什么是 Tree-Shaking 呢?在前端领域，这个概念因 rollup.js 而普及。简单地说，Tree-Shaking 指的就是消除那些永远不会被执行的代码，也就是排除 dead code，现在无论是 rollup.js 还是 webpack，都支持 Tree-Shaking。

想要实现 Tree-Shaking，必须满足一个条件，即模块必须是 ESM(ESModule)因为 Tree-Shaking 依赖 ESM 的静态结构。我们以 rollup.js 为例看看 Tree-Shaking 如何工作，其目录结构如下:

```shell
|---demo
|   |--- package.json
|   |--- input.js
|   |--- utils.js
```

首先安装 rollup.js:

```shell
yarn add rollup -D
# 或者npm install rollup -D
```

下面是 input.js 和 utils.js 文件的内容:

```js
//input.js
import { foo } from './utils.js';
foo();
// utils.js
```

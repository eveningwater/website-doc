# 基础篇：可靠连接的三把刀

与Http短连接相比，使用长连接通信无论是从即时性还是效率方面都有很大的优势。但长连接的稳定性受环境、服务端的影响会断开。如果不能及时检测到并重新与服务端建立连接，可想而知服务端消息就无法及时推送过来。所以本章我们来了解下影响连接稳定性的因素，以及如何解决这个问题。

<div class="image-container">
    <img src="./docs/im/images/29.png" alt="图片6-1" title="图片6-1" >
    <span class="image-title">图 6-1 </span>
</div>

## 影响因素

在谈解决办法之前，首先要搞明白影响长连接稳定的因素，归纳下来有如下几点：

### NAT网关

NAT网关地址转换表中的记录有一个老化时间(aging-time)属性，如果连接空闲超过这个时间，转换记录就会被删除，导致服务端发送给客户端的消息在NAT网关中被丢弃。这个NAT的原理我们在通信协议篇有过讲解，这里不再过多说明。

### 防火墙

在建立连接（SYN包）时，防火墙会记录一条tcp会话数据，这个会话的也是有一个老化时间，超时后防火墙将从会话表中删除此tcp会话信息，此时发送的正常TCP数据包（非SYN）就会被丢弃。

### DHCP

DHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。如果租约到期，而不自动续租导致IP变更，连接也就中断。不过这种情况很少见。

### 网络异常

* 进入网络不稳定环境。由于移动网络数据是通过无线电传输，频率越高，波长越短，穿透力越弱。比如突然进入地下通道或有无线电屏蔽的地方，就会导致丢包很严重。
* 进入网络拥堵的环境。由于NAT网关的处理能力和缓冲区是有上限的，假如在人流量大而集中地方，大量观看视频之类导致接入网关缓冲区不足时，网关就会把收到的数据包丢弃。
* 网络切换等人为原因，比如WIFI切4G等。

### 进程Crash

* 如果服务端主机宕机，TCP连接肯定就中断了。
* 进程用户被杀死，操作系统会关闭连接。

> 思考：在移动网络下，由于人的位置在变动，因此当你从接入的站点A改为接入站点B时，两个站点NAT网关的WAN口IP肯定不一样，那么长接连会断开吗？

### 解决方法

知道了影响连接的因素，就可以针对性采取措施，其中心跳、自动重连就是针性的解决办法。但是在实际的生产环境中，还有一个重要因素需要考虑，就是网关的选择，比如选择就近的网关稳定性肯定就要更好；又比如在网关满负载或者宕机情况下，如果客户端不切换网关，自动重连只会使情况更糟。因此还有一个重要的逻辑智能路由。

## 心跳

心跳指不间断的发送一个较小的数据包，保持长连接活跃，这样就可以解决老化时间一类的问题，只要心跳的间隔时间小于设备要求的老化时间，理论上连接就一直存活。

心跳有两个作用：保活与死连检测，保活的原理在上面已经说明了。这里再说说死连检测是怎么回事，不过在谈它之前，我们需要搞明白两个问题：

> 1. 连接是什么？

如果你仔细看了本小册通信协议两章内容，应该就知道连接是什么了！它不是一条看的见的电线，而是主机到主机之间相关设备的记录，比如操作系统记录的Socket和TCP缓冲区，也比如NAT网关中的地址转换记录。

> 2. 主机是否知道连接是存活的？

主机在不发送数据包的情况下是无法感知到连接是否断开的，。由于TCP协议是可靠传输协议，它其中一个重要特性就是ACK机制。因此，解决“发现”这个问题有两个办法：

1. 只需要发送一个探测包，设置一个写超时，如果底层socket没有收到ACK数据包，上层应用就可以感知到连接是否存活。
2. 客户端与服务端之间协定一个超时时间，在这个时间段之内必须收到对方的数据包，否则认为连接断开。

### 心跳间隔

那么，我们如何设置一个合理的心跳间隔时间呢？

参考的因素主要有两点：

1. 系统开销
2. 感知延迟

从保活的角度，应该尽量使用较大的心跳间隔时间，达到减少系统开销，也就达到减少手机上APP耗电的目的；但是从检测的角度则偏向使用较小的间隔时间，因为间隔越短，连接异常感知延迟就越低，可以马上作出反应。

其中防火墙的老化时间通常都较大，如果服务端有防火墙并且设置的老化时间较小可以内部修改解决。因此主要考虑的就是NAT网关的老化时间的问题，因为它是不可控的，如下是从网上找的运营商TCP地址转换记录的存活时间表：

| 地区/网络                   | NAT Aging-time |
| --------------------------- | -------------- |
| 中国移动4G                  | 1分钟          |
| 中国移动3G、2G              | 5分钟          |
| 中国联通2G、3G、4G          | 5分钟          |
| 中国电信4G                  | 5分钟          |
| 中国电信2G、3G              | 大于28分钟     |
| 台湾和香港各大运营商 4G、3G | 大于28分钟     |
| 美国各大运营商 4G、3G       | 大于28分钟     |

### tcp_keepalive

大多数操作系统都实现了TCP Keepalive机制，只要设置开启就可以了，我们通过这个Keepalive机制来了解下内部逻辑。我们以golang代码为例，在TCPConn中有对应方法：

```golang
// SetKeepAlive sets whether the operating system should send
// keep-alive messages on the connection.
func (c *TCPConn) SetKeepAlive(keepalive bool) error {
	if !c.ok() {
		return syscall.EINVAL
	}
	if err := setKeepAlive(c.fd, keepalive); err != nil {
		return &OpError{Op: "set", Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}
	}
	return nil
}
```

从代码层就可以看出来，在应用层只能决定是否启用它，实际上具体的参数则只能在操作系统层统一设置。如下是我在主机上得到的tcp_keepalive三个关键参数：

```cmd
# cat /proc/sys/net/ipv4/tcp_keepalive_time
7200
# cat /proc/sys/net/ipv4/tcp_keepalive_intvl
75
# cat /proc/sys/net/ipv4/tcp_keepalive_probes
9
```

这个值是可以修改的，它们的单位都是秒。参数的意思是：

* 在连接闲置 tcp_keepalive_time（2小时）后，发送探测包，如果收到回应ACK，便认为连接正常；否则间隔 tcp_keepalive_intvl（75秒） 后，持续发送探测包，一直到发送了 tcp_keepalive_probes（9）个探测包后，还未得到ACK回馈，便认为连接已经中断了。

> 可以看出来，默认的参数设置基本上没有意义，而且修改也不灵活，因此我们通常不直接使用tcp_keepalive，而且是使用业务层自定义心跳。

### 业务心跳

业务心跳指上层应用程序通过定时发送数据包，来达到保活和死连检测的目的。由于是业务层心跳，接收应用进程在收到心跳包需要返回一个ACK，如果进程假死就会导致无法处理返回，发送端就可以检测到，因此业务心跳可以检测两个层次的异常：

1. 连接是否正常。
2. 对方进程是否正常。

实际上理解了上一章节中心跳的原理，那么实现方式就很简单了，也比较灵活，比如websocket协议头中就有ping/pong两种数据包类型，其中一方发送一条ping消息，另一方收到ping消息之间返回一条pong消息。

<div class="image-container">
    <img src="./docs/im/images/30.png" alt="图片6-2" title="图片6-2" >
    <span class="image-title">图 6-2 </span>
</div>

上面演示了一个ping/pong心跳的逻辑，客户端通过定时器或者读超时来判断连接状态，比如在3轮ping包（间隔1分钟）之后还没有收到pong包就认为TCP连接或者对方进程crash了，尝试重连逻辑。

如下是Websocket协议中opcode的定义：

```text
     0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-------+-+-------------+-------------------------------+
     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
     +--------ˆˆˆˆˆˆˆ------------------------------------------------+
  
  Opcode:  4 bits

      Defines the interpretation of the "Payload data".  If an unknown
      opcode is received, the receiving endpoint MUST _Fail the
      WebSocket Connection_.  The following values are defined.

      *  %x0 denotes a continuation frame
      *  %x1 denotes a text frame <---文本
      *  %x2 denotes a binary frame  <---二进制
      *  %x8 denotes a connection close
      *  %x9 denotes a ping <---ping包
      *  %xA denotes a pong <---pong包
```

这里还要涉及到一个ping包是谁发送的问题，通常只有ping的一方才能感知到对方进程是否正常，而不停的发送ping包需要启用一个线程或定时器，无疑是增加了系统开销的。但是如果感知不到异常断开，对服务端来说，会导致tcp连接不释放，间接导致缓冲区与相关对象不被回收，最后的结果就是内存溢出；对客户端来说，就会导致重连延迟变成假死状态，消息就收不到。因此，一种简单的办法就，使用双向心跳，即两方各自发送自己的ping包，收到ping的任何一方都要回复一条pong消息。而本章则会采用另一种方法来解决问题的同时，降低服务端开销。

## 自动重连

心跳可以解决NAT网关等问题，但是无法解决网络异常连接真实断开的场景，所以如果客户端发现TCP连接异常断开，就需要尝试重连，如果在设定的次数或者时间内未连接成功就终止并通知用户，让用户决定何时手动重连。

在这里我重点标出了两个名词：异常断开、次数或时间。我们一个一个来介绍。

异常断开：之所以要说明它，是因为在实际编码的过程中客户端需要知道什么情况下连接断开需要重连，什么情况下不能重连。比如同账号互踢的情况下，服务端就不能直接断开被踢方的连接，而是先发送一条消息给被踢方，告诉对方被踢下线了，否则客户端无法判断断开的情况下就会再次重连，导致相同账号的两端不停互踢。

次数或时间：设置一个重试次数或时间范围是为了在长时间网络故障时减少客户端不必要的重试开销，也是通知用户网络可能出现问题。

## 智能路由

基本上，采用了以上两步可以解决大部分问题。但是如果连接的服务（接入网关）故障，重连也是没有任何作用的，此时就需重连到一台正常的网关。那么客户端如何重连到一台正常网关呢，在这里我们介绍两种方案及它们的优势与劣势！

## SLB（Server Load Balancer）

其中最简单的一个方案就是使用SLB作为网关服务的负载层，如果我们的网关是Websocket协议，可以使用Nginx等应用型负载均衡ALB（Application Load Balancer）作为七层负载。如果是TCP协议，则可以使用传统型负载均衡CLB（Classic Load Balancer）作为四层负载。如图所示：

<div class="image-container">
    <img src="./docs/im/images/31.png" alt="图片6-3" title="图片6-3" >
    <span class="image-title">图 6-3 </span>
</div>

> 如果没有健康检查及自动下线功能，只能通过多次重试落到正常的网关上了。

接下来我们谈谈它的缺点：

其一负载均衡对http等短连接服务非常均衡，但是使用在长连接服务上就不均衡了。无论是使用那种负载算法：随机、轮询、加权轮询、哈希等，作为长连接服务的负载层时都会导致不均衡。

> 我们轮询为例，有两台网关，分别维护了500个连接，一段时间后其中一个网关断开了100个连接，另一个网关断开了400个，此时两个网关中的连接数就是400和100，产生了不平衡；由于断开连接的不确定性，服务永远处于不平衡状态。结果就是一些机器负载过高，一些机器较空闲，不利于资源的利用。

其二通常SLB层只作用于一个服务机房，这对距离很远的用户来说，延迟较高，稳定性就会差，如果是跨了国家，可能都连接不上。

## CLB(Client Load Balancer)

客户端路由及负载均衡是把节点选择的逻辑放到了客户端，通过配置或者接口返回得到一批网关地址，由客户端选择一个正常的网关建立连接。比如我们设计一个最简单的逻辑，如下：

<div class="image-container">
    <img src="./docs/im/images/32.png" alt="图片6-4" title="图片6-4" >
    <span class="image-title">图 6-4 </span>
</div>

图中四个网关都有对外独立的域名或公网ip，在启动时把自己的服务信息注册到注册中心，并通过心跳或者健康检查机制保证节点下线时，注册中心可以感知到，这样可以减少路由服务读取到下线网关的机率，也就减少了客户端的重试次数。如果网关定时同步自己的负载数据到注册中心，路由服务就可以优先选择负载低的网关。

> 当然，一个设计合理的智能路由，肯定不是这么简单，在这里就不展开了，具体的内容会在后面一个章节详细说明。

## 最后总结

本章核心知识点：

1. 影响长连接稳定的五个因素。
2. 心跳的原理及实现逻辑。
3. 自动重连及什么情况下要自动重连。
4. SLB（Server Load Balancer）。
5. CLB(Client Load Balancer)。

理解了核心原理，那么下一章节，我们就动手来实现心跳与自动重连功能。

本章完！

